<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete User Scenarios Test - SeiMoney</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .test-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .test-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .status.pending { background: #ffa500; color: black; }
        .status.running { background: #00bfff; color: black; }
        .status.passed { background: #00ff00; color: black; }
        .status.failed { background: #ff4444; color: white; }
        
        .btn {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            color: black;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
        }
        
        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .log {
            background: #000;
            border-radius: 6px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
            border: 1px solid #333;
        }
        
        .wallet-info {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        .results-summary {
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-top: 30px;
        }
        
        .metric {
            display: inline-block;
            margin: 10px 20px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
        }
        
        .metric-label {
            font-size: 12px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß™ Complete User Scenarios Test</h1>
            <p>End-to-end testing of SeiMoney platform with real blockchain data</p>
        </div>

        <!-- Wallet Connection Section -->
        <div class="test-section">
            <h2>üîó Wallet Connection</h2>
            <div class="wallet-info" id="walletInfo">
                <p><strong>Status:</strong> <span id="walletStatus">Not Connected</span></p>
                <p><strong>Address:</strong> <span id="walletAddress">-</span></p>
                <p><strong>Balance:</strong> <span id="walletBalance">-</span></p>
            </div>
            <button class="btn" onclick="connectKeplr()">Connect Keplr</button>
            <button class="btn" onclick="connectLeap()">Connect Leap</button>
            <button class="btn" onclick="disconnectWallet()">Disconnect</button>
        </div>

        <!-- Test Progress -->
        <div class="test-section">
            <h2>üìä Test Progress</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <p id="progressText">Ready to start tests</p>
        </div>

        <!-- Test Categories -->
        <div class="test-grid">
            <!-- Transfer Tests -->
            <div class="test-card">
                <h3>üîÑ Transfer Workflows</h3>
                <div id="transferTests">
                    <div class="test-item">
                        <span>Create Transfer:</span>
                        <span class="status pending" id="createTransferStatus">Pending</span>
                    </div>
                    <div class="test-item">
                        <span>Claim Transfer:</span>
                        <span class="status pending" id="claimTransferStatus">Pending</span>
                    </div>
                    <div class="test-item">
                        <span>Refund Transfer:</span>
                        <span class="status pending" id="refundTransferStatus">Pending</span>
                    </div>
                </div>
                <button class="btn" onclick="runTransferTests()" id="transferTestBtn">Run Transfer Tests</button>
            </div>

            <!-- Group Tests -->
            <div class="test-card">
                <h3>üë• Group Pool Workflows</h3>
                <div id="groupTests">
                    <div class="test-item">
                        <span>Create Group:</span>
                        <span class="status pending" id="createGroupStatus">Pending</span>
                    </div>
                    <div class="test-item">
                        <span>Contribute to Group:</span>
                        <span class="status pending" id="contributeGroupStatus">Pending</span>
                    </div>
                    <div class="test-item">
                        <span>Track Progress:</span>
                        <span class="status pending" id="trackGroupStatus">Pending</span>
                    </div>
                </div>
                <button class="btn" onclick="runGroupTests()" id="groupTestBtn">Run Group Tests</button>
            </div>

            <!-- Vault Tests -->
            <div class="test-card">
                <h3>üè¶ Vault Workflows</h3>
                <div id="vaultTests">
                    <div class="test-item">
                        <span>Deposit to Vault:</span>
                        <span class="status pending" id="depositVaultStatus">Pending</span>
                    </div>
                    <div class="test-item">
                        <span>Check Position:</span>
                        <span class="status pending" id="positionVaultStatus">Pending</span>
                    </div>
                    <div class="test-item">
                        <span>Withdraw from Vault:</span>
                        <span class="status pending" id="withdrawVaultStatus">Pending</span>
                    </div>
                </div>
                <button class="btn" onclick="runVaultTests()" id="vaultTestBtn">Run Vault Tests</button>
            </div>

            <!-- Pot Tests -->
            <div class="test-card">
                <h3>üè∫ Savings Pot Workflows</h3>
                <div id="potTests">
                    <div class="test-item">
                        <span>Create Pot:</span>
                        <span class="status pending" id="createPotStatus">Pending</span>
                    </div>
                    <div class="test-item">
                        <span>Deposit to Pot:</span>
                        <span class="status pending" id="depositPotStatus">Pending</span>
                    </div>
                    <div class="test-item">
                        <span>Track Goal:</span>
                        <span class="status pending" id="trackPotStatus">Pending</span>
                    </div>
                </div>
                <button class="btn" onclick="runPotTests()" id="potTestBtn">Run Pot Tests</button>
            </div>
        </div>

        <!-- Control Buttons -->
        <div class="test-section">
            <h2>üéÆ Test Controls</h2>
            <button class="btn" onclick="runAllTests()" id="runAllBtn">Run All Tests</button>
            <button class="btn" onclick="resetTests()">Reset Tests</button>
            <button class="btn" onclick="exportResults()">Export Results</button>
        </div>

        <!-- Test Log -->
        <div class="test-section">
            <h2>üìù Test Log</h2>
            <div class="log" id="testLog"></div>
        </div>

        <!-- Results Summary -->
        <div class="results-summary" id="resultsSummary" style="display: none;">
            <h2>üìä Test Results Summary</h2>
            <div class="metric">
                <div class="metric-value" id="totalTests">0</div>
                <div class="metric-label">Total Tests</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="passedTests">0</div>
                <div class="metric-label">Passed</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="failedTests">0</div>
                <div class="metric-label">Failed</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="successRate">0%</div>
                <div class="metric-label">Success Rate</div>
            </div>
        </div>
    </div>

    <script>
        // Test state management
        let testState = {
            wallet: null,
            connected: false,
            tests: {
                transfers: { passed: 0, failed: 0, total: 3 },
                groups: { passed: 0, failed: 0, total: 3 },
                vaults: { passed: 0, failed: 0, total: 3 },
                pots: { passed: 0, failed: 0, total: 3 }
            },
            currentTest: null,
            testData: {}
        };

        // API Configuration
        const API_BASE = 'http://localhost:3001/api';
        const CONTRACTS = {
            PAYMENTS: "sei1kfpm92hs5gsmp84098wc3jpy2a440l50cq2ycsxlkpnlaygl9azqdhsygg",
            GROUPS: "sei1vq3ncyvf4k22lc0xhm7x6dtkn6jyxkexa2xy6uk2sj33dysnyy2syn73qt",
            POTS: "sei1c5d4flfqv3zjms0g894z82hnhv62h2vjr9hgd05c6xh456q8xjfq8f3qmj",
            VAULTS: "sei12k2yxf3cyec8p89qtgm5w30m4g2775tn7j8wx4jpuallygu45r9qs68u2h"
        };

        // Utility functions
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('testLog');
            const color = type === 'error' ? '#ff4444' : type === 'success' ? '#00ff88' : '#ffffff';
            logElement.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        function updateStatus(elementId, status) {
            const element = document.getElementById(elementId);
            element.className = `status ${status}`;
            element.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        }

        function updateProgress() {
            const totalTests = Object.values(testState.tests).reduce((sum, cat) => sum + cat.total, 0);
            const completedTests = Object.values(testState.tests).reduce((sum, cat) => sum + cat.passed + cat.failed, 0);
            const progress = (completedTests / totalTests) * 100;
            
            document.getElementById('progressFill').style.width = `${progress}%`;
            document.getElementById('progressText').textContent = `${completedTests}/${totalTests} tests completed (${progress.toFixed(1)}%)`;
        }

        function showResults() {
            const totalTests = Object.values(testState.tests).reduce((sum, cat) => sum + cat.total, 0);
            const passedTests = Object.values(testState.tests).reduce((sum, cat) => sum + cat.passed, 0);
            const failedTests = Object.values(testState.tests).reduce((sum, cat) => sum + cat.failed, 0);
            const successRate = totalTests > 0 ? ((passedTests / totalTests) * 100).toFixed(1) : 0;

            document.getElementById('totalTests').textContent = totalTests;
            document.getElementById('passedTests').textContent = passedTests;
            document.getElementById('failedTests').textContent = failedTests;
            document.getElementById('successRate').textContent = `${successRate}%`;
            document.getElementById('resultsSummary').style.display = 'block';
        }

        // Wallet connection functions
        async function connectKeplr() {
            try {
                log('Connecting to Keplr wallet...', 'info');
                
                if (!window.keplr) {
                    throw new Error('Keplr wallet not found. Please install Keplr extension.');
                }

                // Enable Sei testnet
                await window.keplr.enable('atlantic-2');
                
                // Get offline signer
                const offlineSigner = window.keplr.getOfflineSigner('atlantic-2');
                const accounts = await offlineSigner.getAccounts();
                
                testState.wallet = {
                    address: accounts[0].address,
                    provider: 'keplr',
                    signer: offlineSigner
                };
                testState.connected = true;

                // Update UI
                document.getElementById('walletStatus').textContent = 'Connected (Keplr)';
                document.getElementById('walletAddress').textContent = accounts[0].address;
                
                // Get balance
                await updateWalletBalance();
                
                log(`‚úÖ Connected to Keplr: ${accounts[0].address}`, 'success');
                
            } catch (error) {
                log(`‚ùå Keplr connection failed: ${error.message}`, 'error');
            }
        }

        async function connectLeap() {
            try {
                log('Connecting to Leap wallet...', 'info');
                
                if (!window.leap) {
                    throw new Error('Leap wallet not found. Please install Leap extension.');
                }

                // Enable Sei testnet
                await window.leap.enable('atlantic-2');
                
                // Get offline signer
                const offlineSigner = window.leap.getOfflineSigner('atlantic-2');
                const accounts = await offlineSigner.getAccounts();
                
                testState.wallet = {
                    address: accounts[0].address,
                    provider: 'leap',
                    signer: offlineSigner
                };
                testState.connected = true;

                // Update UI
                document.getElementById('walletStatus').textContent = 'Connected (Leap)';
                document.getElementById('walletAddress').textContent = accounts[0].address;
                
                // Get balance
                await updateWalletBalance();
                
                log(`‚úÖ Connected to Leap: ${accounts[0].address}`, 'success');
                
            } catch (error) {
                log(`‚ùå Leap connection failed: ${error.message}`, 'error');
            }
        }

        function disconnectWallet() {
            testState.wallet = null;
            testState.connected = false;
            
            document.getElementById('walletStatus').textContent = 'Not Connected';
            document.getElementById('walletAddress').textContent = '-';
            document.getElementById('walletBalance').textContent = '-';
            
            log('üîå Wallet disconnected', 'info');
        }

        async function updateWalletBalance() {
            if (!testState.connected) return;
            
            try {
                const response = await fetch(`${API_BASE}/wallet/balance`, {
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const seiBalance = data.data.find(coin => coin.denom === 'usei');
                    const balance = seiBalance ? (parseInt(seiBalance.amount) / 1000000).toFixed(6) : '0';
                    document.getElementById('walletBalance').textContent = `${balance} SEI`;
                } else {
                    document.getElementById('walletBalance').textContent = 'Error loading balance';
                }
            } catch (error) {
                log(`‚ö†Ô∏è Balance update failed: ${error.message}`, 'error');
                document.getElementById('walletBalance').textContent = 'Error';
            }
        }

        // Test execution functions
        async function runTransferTests() {
            if (!testState.connected) {
                log('‚ùå Please connect wallet first', 'error');
                return;
            }

            log('üîÑ Starting Transfer Tests...', 'info');
            document.getElementById('transferTestBtn').disabled = true;

            try {
                // Test 1: Create Transfer
                updateStatus('createTransferStatus', 'running');
                const createResult = await testCreateTransfer();
                if (createResult.success) {
                    updateStatus('createTransferStatus', 'passed');
                    testState.tests.transfers.passed++;
                    testState.testData.transferId = createResult.transferId;
                    log('‚úÖ Transfer creation: PASSED', 'success');
                } else {
                    updateStatus('createTransferStatus', 'failed');
                    testState.tests.transfers.failed++;
                    log('‚ùå Transfer creation: FAILED', 'error');
                }

                // Test 2: Claim Transfer (if create succeeded)
                if (createResult.success && testState.testData.transferId) {
                    updateStatus('claimTransferStatus', 'running');
                    const claimResult = await testClaimTransfer(testState.testData.transferId);
                    if (claimResult.success) {
                        updateStatus('claimTransferStatus', 'passed');
                        testState.tests.transfers.passed++;
                        log('‚úÖ Transfer claim: PASSED', 'success');
                    } else {
                        updateStatus('claimTransferStatus', 'failed');
                        testState.tests.transfers.failed++;
                        log('‚ùå Transfer claim: FAILED', 'error');
                    }
                } else {
                    updateStatus('claimTransferStatus', 'failed');
                    testState.tests.transfers.failed++;
                }

                // Test 3: Refund Transfer
                updateStatus('refundTransferStatus', 'running');
                const refundResult = await testRefundTransfer();
                if (refundResult.success) {
                    updateStatus('refundTransferStatus', 'passed');
                    testState.tests.transfers.passed++;
                    log('‚úÖ Transfer refund: PASSED', 'success');
                } else {
                    updateStatus('refundTransferStatus', 'failed');
                    testState.tests.transfers.failed++;
                    log('‚ùå Transfer refund: FAILED', 'error');
                }

            } catch (error) {
                log(`‚ùå Transfer tests failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('transferTestBtn').disabled = false;
                updateProgress();
            }
        }

        async function testCreateTransfer() {
            try {
                const transferData = {
                    recipient: 'sei1test123456789abcdefghijklmnopqrstuvwxyz1234567890abc', // Test recipient
                    amount: '1000000', // 1 SEI
                    expiry: new Date(Date.now() + 3600000).toISOString(), // 1 hour
                    remark: 'Test transfer from complete user scenarios'
                };

                const response = await fetch(`${API_BASE}/transfers`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(transferData)
                });

                if (response.ok) {
                    const result = await response.json();
                    log(`üì§ Transfer created with ID: ${result.data.transferId}`, 'success');
                    return { success: true, transferId: result.data.transferId };
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Transfer creation failed');
                }
            } catch (error) {
                log(`‚ùå Create transfer error: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        async function testClaimTransfer(transferId) {
            try {
                const response = await fetch(`${API_BASE}/transfers/${transferId}/claim`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const result = await response.json();
                    log(`üì• Transfer ${transferId} claimed successfully`, 'success');
                    return { success: true };
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Transfer claim failed');
                }
            } catch (error) {
                log(`‚ùå Claim transfer error: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        async function testRefundTransfer() {
            try {
                // Create a transfer first for refund test
                const transferData = {
                    recipient: 'sei1test123456789abcdefghijklmnopqrstuvwxyz1234567890abc',
                    amount: '500000', // 0.5 SEI
                    expiry: new Date(Date.now() + 60000).toISOString(), // 1 minute
                    remark: 'Test refund transfer'
                };

                const createResponse = await fetch(`${API_BASE}/transfers`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(transferData)
                });

                if (!createResponse.ok) {
                    throw new Error('Failed to create transfer for refund test');
                }

                const createResult = await createResponse.json();
                const transferId = createResult.data.transferId;

                // Wait a moment then refund
                await new Promise(resolve => setTimeout(resolve, 2000));

                const refundResponse = await fetch(`${API_BASE}/transfers/${transferId}/refund`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (refundResponse.ok) {
                    log(`üîÑ Transfer ${transferId} refunded successfully`, 'success');
                    return { success: true };
                } else {
                    const error = await refundResponse.json();
                    throw new Error(error.error || 'Transfer refund failed');
                }
            } catch (error) {
                log(`‚ùå Refund transfer error: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        async function runGroupTests() {
            if (!testState.connected) {
                log('‚ùå Please connect wallet first', 'error');
                return;
            }

            log('üë• Starting Group Tests...', 'info');
            document.getElementById('groupTestBtn').disabled = true;

            try {
                // Test 1: Create Group
                updateStatus('createGroupStatus', 'running');
                const createResult = await testCreateGroup();
                if (createResult.success) {
                    updateStatus('createGroupStatus', 'passed');
                    testState.tests.groups.passed++;
                    testState.testData.groupId = createResult.groupId;
                    log('‚úÖ Group creation: PASSED', 'success');
                } else {
                    updateStatus('createGroupStatus', 'failed');
                    testState.tests.groups.failed++;
                    log('‚ùå Group creation: FAILED', 'error');
                }

                // Test 2: Contribute to Group
                if (createResult.success && testState.testData.groupId) {
                    updateStatus('contributeGroupStatus', 'running');
                    const contributeResult = await testContributeToGroup(testState.testData.groupId);
                    if (contributeResult.success) {
                        updateStatus('contributeGroupStatus', 'passed');
                        testState.tests.groups.passed++;
                        log('‚úÖ Group contribution: PASSED', 'success');
                    } else {
                        updateStatus('contributeGroupStatus', 'failed');
                        testState.tests.groups.failed++;
                        log('‚ùå Group contribution: FAILED', 'error');
                    }
                } else {
                    updateStatus('contributeGroupStatus', 'failed');
                    testState.tests.groups.failed++;
                }

                // Test 3: Track Group Progress
                if (testState.testData.groupId) {
                    updateStatus('trackGroupStatus', 'running');
                    const trackResult = await testTrackGroupProgress(testState.testData.groupId);
                    if (trackResult.success) {
                        updateStatus('trackGroupStatus', 'passed');
                        testState.tests.groups.passed++;
                        log('‚úÖ Group progress tracking: PASSED', 'success');
                    } else {
                        updateStatus('trackGroupStatus', 'failed');
                        testState.tests.groups.failed++;
                        log('‚ùå Group progress tracking: FAILED', 'error');
                    }
                } else {
                    updateStatus('trackGroupStatus', 'failed');
                    testState.tests.groups.failed++;
                }

            } catch (error) {
                log(`‚ùå Group tests failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('groupTestBtn').disabled = false;
                updateProgress();
            }
        }

        async function testCreateGroup() {
            try {
                const groupData = {
                    name: `Test Group ${Date.now()}`,
                    target: '10000000', // 10 SEI
                    maxParticipants: 5,
                    expiry: new Date(Date.now() + 86400000).toISOString(), // 24 hours
                    description: 'Test group from complete user scenarios'
                };

                const response = await fetch(`${API_BASE}/groups`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(groupData)
                });

                if (response.ok) {
                    const result = await response.json();
                    log(`üë• Group created with ID: ${result.data.groupId}`, 'success');
                    return { success: true, groupId: result.data.groupId };
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Group creation failed');
                }
            } catch (error) {
                log(`‚ùå Create group error: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        async function testContributeToGroup(groupId) {
            try {
                const contributionData = {
                    amount: '2000000' // 2 SEI
                };

                const response = await fetch(`${API_BASE}/groups/${groupId}/contribute`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(contributionData)
                });

                if (response.ok) {
                    log(`üí∞ Contributed to group ${groupId}`, 'success');
                    return { success: true };
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Group contribution failed');
                }
            } catch (error) {
                log(`‚ùå Group contribution error: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        async function testTrackGroupProgress(groupId) {
            try {
                const response = await fetch(`${API_BASE}/groups/${groupId}`, {
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const result = await response.json();
                    const group = result.data;
                    const progress = (parseInt(group.currentAmount) / parseInt(group.target)) * 100;
                    log(`üìä Group ${groupId} progress: ${progress.toFixed(2)}%`, 'success');
                    return { success: true, progress };
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Group progress check failed');
                }
            } catch (error) {
                log(`‚ùå Group progress error: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        async function runVaultTests() {
            if (!testState.connected) {
                log('‚ùå Please connect wallet first', 'error');
                return;
            }

            log('üè¶ Starting Vault Tests...', 'info');
            document.getElementById('vaultTestBtn').disabled = true;

            try {
                // Get available vaults first
                const vaultsResponse = await fetch(`${API_BASE}/vaults`, {
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!vaultsResponse.ok) {
                    throw new Error('Failed to fetch vaults');
                }

                const vaultsResult = await vaultsResponse.json();
                const vaults = vaultsResult.data;

                if (vaults.length === 0) {
                    log('‚ö†Ô∏è No vaults available for testing', 'error');
                    return;
                }

                const testVault = vaults[0];
                testState.testData.vaultId = testVault.id;

                // Test 1: Deposit to Vault
                updateStatus('depositVaultStatus', 'running');
                const depositResult = await testVaultDeposit(testVault.id);
                if (depositResult.success) {
                    updateStatus('depositVaultStatus', 'passed');
                    testState.tests.vaults.passed++;
                    log('‚úÖ Vault deposit: PASSED', 'success');
                } else {
                    updateStatus('depositVaultStatus', 'failed');
                    testState.tests.vaults.failed++;
                    log('‚ùå Vault deposit: FAILED', 'error');
                }

                // Test 2: Check Vault Position
                updateStatus('positionVaultStatus', 'running');
                const positionResult = await testVaultPosition(testVault.id);
                if (positionResult.success) {
                    updateStatus('positionVaultStatus', 'passed');
                    testState.tests.vaults.passed++;
                    testState.testData.vaultShares = positionResult.shares;
                    log('‚úÖ Vault position check: PASSED', 'success');
                } else {
                    updateStatus('positionVaultStatus', 'failed');
                    testState.tests.vaults.failed++;
                    log('‚ùå Vault position check: FAILED', 'error');
                }

                // Test 3: Withdraw from Vault
                if (positionResult.success && testState.testData.vaultShares > 0) {
                    updateStatus('withdrawVaultStatus', 'running');
                    const withdrawResult = await testVaultWithdraw(testVault.id, testState.testData.vaultShares);
                    if (withdrawResult.success) {
                        updateStatus('withdrawVaultStatus', 'passed');
                        testState.tests.vaults.passed++;
                        log('‚úÖ Vault withdrawal: PASSED', 'success');
                    } else {
                        updateStatus('withdrawVaultStatus', 'failed');
                        testState.tests.vaults.failed++;
                        log('‚ùå Vault withdrawal: FAILED', 'error');
                    }
                } else {
                    updateStatus('withdrawVaultStatus', 'failed');
                    testState.tests.vaults.failed++;
                }

            } catch (error) {
                log(`‚ùå Vault tests failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('vaultTestBtn').disabled = false;
                updateProgress();
            }
        }

        async function testVaultDeposit(vaultId) {
            try {
                const depositData = {
                    amount: '5000000' // 5 SEI
                };

                const response = await fetch(`${API_BASE}/vaults/${vaultId}/deposit`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(depositData)
                });

                if (response.ok) {
                    log(`üí∞ Deposited to vault ${vaultId}`, 'success');
                    return { success: true };
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Vault deposit failed');
                }
            } catch (error) {
                log(`‚ùå Vault deposit error: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        async function testVaultPosition(vaultId) {
            try {
                const response = await fetch(`${API_BASE}/vaults/${vaultId}/position`, {
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const result = await response.json();
                    const position = result.data;
                    log(`üìä Vault position: ${position.shares} shares (${position.value} SEI)`, 'success');
                    return { success: true, shares: parseFloat(position.shares), value: position.value };
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Vault position check failed');
                }
            } catch (error) {
                log(`‚ùå Vault position error: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        async function testVaultWithdraw(vaultId, shares) {
            try {
                const withdrawData = {
                    shares: Math.floor(shares / 2).toString() // Withdraw half
                };

                const response = await fetch(`${API_BASE}/vaults/${vaultId}/withdraw`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(withdrawData)
                });

                if (response.ok) {
                    log(`üí∏ Withdrew from vault ${vaultId}`, 'success');
                    return { success: true };
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Vault withdrawal failed');
                }
            } catch (error) {
                log(`‚ùå Vault withdrawal error: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        async function runPotTests() {
            if (!testState.connected) {
                log('‚ùå Please connect wallet first', 'error');
                return;
            }

            log('üè∫ Starting Pot Tests...', 'info');
            document.getElementById('potTestBtn').disabled = true;

            try {
                // Test 1: Create Pot
                updateStatus('createPotStatus', 'running');
                const createResult = await testCreatePot();
                if (createResult.success) {
                    updateStatus('createPotStatus', 'passed');
                    testState.tests.pots.passed++;
                    testState.testData.potId = createResult.potId;
                    log('‚úÖ Pot creation: PASSED', 'success');
                } else {
                    updateStatus('createPotStatus', 'failed');
                    testState.tests.pots.failed++;
                    log('‚ùå Pot creation: FAILED', 'error');
                }

                // Test 2: Deposit to Pot
                if (createResult.success && testState.testData.potId) {
                    updateStatus('depositPotStatus', 'running');
                    const depositResult = await testPotDeposit(testState.testData.potId);
                    if (depositResult.success) {
                        updateStatus('depositPotStatus', 'passed');
                        testState.tests.pots.passed++;
                        log('‚úÖ Pot deposit: PASSED', 'success');
                    } else {
                        updateStatus('depositPotStatus', 'failed');
                        testState.tests.pots.failed++;
                        log('‚ùå Pot deposit: FAILED', 'error');
                    }
                } else {
                    updateStatus('depositPotStatus', 'failed');
                    testState.tests.pots.failed++;
                }

                // Test 3: Track Goal Progress
                if (testState.testData.potId) {
                    updateStatus('trackPotStatus', 'running');
                    const trackResult = await testTrackPotProgress(testState.testData.potId);
                    if (trackResult.success) {
                        updateStatus('trackPotStatus', 'passed');
                        testState.tests.pots.passed++;
                        log('‚úÖ Pot progress tracking: PASSED', 'success');
                    } else {
                        updateStatus('trackPotStatus', 'failed');
                        testState.tests.pots.failed++;
                        log('‚ùå Pot progress tracking: FAILED', 'error');
                    }
                } else {
                    updateStatus('trackPotStatus', 'failed');
                    testState.tests.pots.failed++;
                }

            } catch (error) {
                log(`‚ùå Pot tests failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('potTestBtn').disabled = false;
                updateProgress();
            }
        }

        async function testCreatePot() {
            try {
                const potData = {
                    label: `Test Savings Pot ${Date.now()}`,
                    target: '20000000', // 20 SEI
                    deadline: new Date(Date.now() + 86400000 * 30).toISOString(), // 30 days
                    description: 'Test savings pot from complete user scenarios'
                };

                const response = await fetch(`${API_BASE}/pots`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(potData)
                });

                if (response.ok) {
                    const result = await response.json();
                    log(`üè∫ Pot created with ID: ${result.data.potId}`, 'success');
                    return { success: true, potId: result.data.potId };
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Pot creation failed');
                }
            } catch (error) {
                log(`‚ùå Create pot error: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        async function testPotDeposit(potId) {
            try {
                const depositData = {
                    amount: '3000000' // 3 SEI
                };

                const response = await fetch(`${API_BASE}/pots/${potId}/deposit`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(depositData)
                });

                if (response.ok) {
                    log(`üí∞ Deposited to pot ${potId}`, 'success');
                    return { success: true };
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Pot deposit failed');
                }
            } catch (error) {
                log(`‚ùå Pot deposit error: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        async function testTrackPotProgress(potId) {
            try {
                const response = await fetch(`${API_BASE}/pots/${potId}`, {
                    headers: {
                        'Authorization': `Bearer ${testState.wallet.address}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const result = await response.json();
                    const pot = result.data;
                    const progress = (parseInt(pot.currentAmount) / parseInt(pot.target)) * 100;
                    log(`üìä Pot ${potId} progress: ${progress.toFixed(2)}%`, 'success');
                    return { success: true, progress };
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Pot progress check failed');
                }
            } catch (error) {
                log(`‚ùå Pot progress error: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        // Main test runner
        async function runAllTests() {
            if (!testState.connected) {
                log('‚ùå Please connect wallet first', 'error');
                return;
            }

            log('üöÄ Starting Complete User Test Scenarios...', 'info');
            document.getElementById('runAllBtn').disabled = true;

            try {
                await runTransferTests();
                await new Promise(resolve => setTimeout(resolve, 2000)); // Wait between test suites
                
                await runGroupTests();
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                await runVaultTests();
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                await runPotTests();

                log('üéâ All test scenarios completed!', 'success');
                showResults();

            } catch (error) {
                log(`‚ùå Test execution failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('runAllBtn').disabled = false;
            }
        }

        function resetTests() {
            // Reset test state
            testState.tests = {
                transfers: { passed: 0, failed: 0, total: 3 },
                groups: { passed: 0, failed: 0, total: 3 },
                vaults: { passed: 0, failed: 0, total: 3 },
                pots: { passed: 0, failed: 0, total: 3 }
            };
            testState.testData = {};

            // Reset UI
            const statusElements = [
                'createTransferStatus', 'claimTransferStatus', 'refundTransferStatus',
                'createGroupStatus', 'contributeGroupStatus', 'trackGroupStatus',
                'depositVaultStatus', 'positionVaultStatus', 'withdrawVaultStatus',
                'createPotStatus', 'depositPotStatus', 'trackPotStatus'
            ];

            statusElements.forEach(id => updateStatus(id, 'pending'));

            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressText').textContent = 'Ready to start tests';
            document.getElementById('testLog').innerHTML = '';
            document.getElementById('resultsSummary').style.display = 'none';

            // Re-enable buttons
            document.getElementById('transferTestBtn').disabled = false;
            document.getElementById('groupTestBtn').disabled = false;
            document.getElementById('vaultTestBtn').disabled = false;
            document.getElementById('potTestBtn').disabled = false;
            document.getElementById('runAllBtn').disabled = false;

            log('üîÑ Tests reset', 'info');
        }

        function exportResults() {
            const results = {
                timestamp: new Date().toISOString(),
                wallet: testState.wallet ? {
                    address: testState.wallet.address,
                    provider: testState.wallet.provider
                } : null,
                tests: testState.tests,
                summary: {
                    totalTests: Object.values(testState.tests).reduce((sum, cat) => sum + cat.total, 0),
                    passedTests: Object.values(testState.tests).reduce((sum, cat) => sum + cat.passed, 0),
                    failedTests: Object.values(testState.tests).reduce((sum, cat) => sum + cat.failed, 0)
                }
            };

            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `seimoney-test-results-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            log('üìÑ Test results exported', 'success');
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            log('üß™ Complete User Scenarios Test initialized', 'info');
            log('Connect your wallet to begin testing real data integration', 'info');
        });
    </script>
</body>
</html>